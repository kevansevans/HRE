package gb;

/**
 * ...
 * @author Kaelan
 */
class Memory {
	public var _inbios:Bool = true;
	var _ie:Int = 0;
	var _if:Int = 0;
	var _rom:String = "";
	var _romoffset = 0x4000;
	var _ramoffset = 0;
	var _carttype:Int = 0;
	var _eram:Map<Int, Int> = new Map();
	var _wram:Map<Int, Int> = new Map();
	var _zram:Map<Int, Int> = new Map();
	public var _bios:Array<Int> = [
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
	];
	public function new() {
		for (a in 0...8192) {_wram[a] = 0; }
		trace("Wram good");
		for (b in 0...32768) {_eram[b] = 0; }
		trace("Eram good");
		for (a in 0...127) {_zram[a] = 0; }
		trace("Zram good");
	}
	public function load(_romdata:String) {
		_rom = _romdata;
	}
	public function read_byte(_addr:Int):Int {
		switch(_addr & 0xF000) {
			case 0x0000 :
				if (_inbios) {
					if (_addr < 0x0100) return _bios[_addr];
					else if (CPU_GB._register[Register.pc] == 0x100) {
						_inbios = false;
						trace("Leaving Bios");
					}
				} else {
					return _rom.charCodeAt(_addr);
				}
			case 0x1000 | 0x2000 | 0x3000 :
				return _rom.charCodeAt(_addr);
			//rom bank 1
			case 0x4000 | 0x5000 | 0x6000 | 0x7000 :
				return _rom.charCodeAt(_romoffset + (_addr & 0x3FFF));
			//vram	
			case 0x8000 | 0x9000 :
				trace("I don't have a GPU yet!");
				return 0;
			//external ram
			case 0xA000 | 0xB000 :
				return _eram[_ramoffset + (_addr & 0x1FFF)];
			//Work ram and Echo
			case 0xC000 | 0xD000 | 0xE000 :
				return _wram[_addr & 0x1FFF];
			//Everything else
			case 0xF000 :
				switch (_addr & 0x0F00) {
					case 0x000 | 0x100 | 0x200 | 0x300 | 0x400 | 0x500 | 0x600 | 0x700 | 0x800 | 0x900 | 0xA00 | 0xB00 | 0xC00 | 0xD00 :
						return _wram[_addr & 0x1FFF];
					case 0xE00 :
						trace("I need a GPU here!");
						return 0;
					case 0xF00 :
						if (_addr == 0xFFFF) return _ie;
						else if (_addr > 0xFF7F) return _zram[_addr & 0x7F];
						else {
							switch (_addr & 0xF0) {
								case 0x00 :
									switch (_addr & 0xF) {
										case 0 :
											trace("Joypad here");
											return 0;
										case 4 | 5 | 6 | 7 :
											trace("timer here");
											return 0;
										case 15 :
											return _if;
										default :
											return 0; //actually needed default
									}
								case 0x10 | 0x20 | 0x30 :
									return 0;
								case 0x40 | 0x50 | 0x60 | 0x70 :
									trace("New gpu who dis?");
									return 0;
							}
						}
				}
			default :
				trace("Fix me!", _addr);
				return 0;
		}
		return 0;
	}
	public function read_word(_addr):Int {
		return read_byte(_addr) + (read_byte(_addr + 1) << 8);
	}
	public function write_byte(_addr, _value) {
		
	}
	public function write_word(_addr, _value) {
		
	}
}